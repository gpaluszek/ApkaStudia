{"ast":null,"code":"let IDX = 36;\nlet HEX = \"\";\nwhile (IDX--) {\n  HEX += IDX.toString(36);\n}\nfunction uid() {\n  let len = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 11;\n  let str = \"\";\n  let num = len;\n  while (num--) {\n    str += HEX[Math.random() * 36 | 0];\n  }\n  return str;\n}\nconst escapeRegexp = term => term.replace(/[|\\\\{}()[\\]^$+*?.-]/g, char => `\\\\${char}`);\nconst termsToRegExpString = terms => {\n  return terms.replace(/\\s{2,}/g, \" \").split(\" \").join(\"|\");\n};\nconst regexpQuery = _ref => {\n  let {\n    terms,\n    matchExactly = false\n  } = _ref;\n  if (typeof terms !== \"string\") {\n    throw new TypeError(\"Expected a string\");\n  }\n  const escapedTerms = escapeRegexp(terms.trim());\n  return `(${matchExactly ? escapedTerms : termsToRegExpString(escapedTerms)})`;\n};\nconst buildRegexp = _ref2 => {\n  let {\n    terms,\n    matchExactly = false\n  } = _ref2;\n  try {\n    const fromString = /^([/~@;%#'])(.*?)\\1([gimsuy]*)$/.exec(terms);\n    if (fromString) {\n      return new RegExp(fromString[2], fromString[3]);\n    }\n    return new RegExp(regexpQuery({\n      terms,\n      matchExactly\n    }), \"ig\");\n  } catch (e) {\n    throw new TypeError(\"Expected terms to be either a string or a RegExp!\");\n  }\n};\nconst hasProp = prop => obj => obj !== null && typeof obj !== \"undefined\" && prop in obj;\nconst hasMatch = hasProp(\"match\");\nconst chunkExists = chunk => typeof chunk !== \"undefined\";\nfunction clip(_ref3) {\n  let {\n    curr,\n    next,\n    prev,\n    clipBy = 3\n  } = _ref3;\n  const words = curr.text.split(\" \");\n  const len = words.length;\n  if (curr.match || clipBy >= len) {\n    return curr.text;\n  }\n  const ellipsis = \"...\";\n  if (chunkExists(next) && chunkExists(prev) && hasMatch(prev) && hasMatch(next)) {\n    if (len > clipBy * 2) {\n      return [...words.slice(0, clipBy), ellipsis, ...words.slice(-clipBy)].join(\" \");\n    }\n    return curr.text;\n  }\n  if (chunkExists(next) && hasMatch(next)) {\n    return [ellipsis, ...words.slice(-clipBy)].join(\" \");\n  }\n  if (chunkExists(prev) && hasMatch(prev)) {\n    return [...words.slice(0, clipBy), ellipsis].join(\" \");\n  }\n  return curr.text;\n}\nvar __assign = Object.assign;\nconst hasLength = str => str.length > 0;\nconst highlightWords = _ref4 => {\n  let {\n    text,\n    query,\n    clipBy,\n    matchExactly = false\n  } = _ref4;\n  const safeQuery = typeof query === \"string\" ? query.trim() : query;\n  if (safeQuery === \"\") {\n    return [{\n      key: uid(),\n      text,\n      match: false\n    }];\n  }\n  const searchRegexp = buildRegexp({\n    terms: query,\n    matchExactly\n  });\n  return text.split(searchRegexp).filter(hasLength).map(str => ({\n    key: uid(),\n    text: str,\n    match: matchExactly ? str.toLowerCase() === safeQuery.toLowerCase() : searchRegexp.test(str)\n  })).map((chunk, index, chunks) => __assign(__assign({}, chunk), typeof clipBy === \"number\" && {\n    text: clip(__assign(__assign(__assign({\n      curr: chunk\n    }, index < chunks.length - 1 && {\n      next: chunks[index + 1]\n    }), index > 0 && {\n      prev: chunks[index - 1]\n    }), {\n      clipBy\n    }))\n  }));\n};\nexport default highlightWords;","map":{"version":3,"names":["IDX","HEX","toString","uid","len","arguments","length","undefined","str","num","Math","random","escapeRegexp","term","replace","char","termsToRegExpString","terms","split","join","regexpQuery","_ref","matchExactly","TypeError","escapedTerms","trim","buildRegexp","_ref2","fromString","exec","RegExp","e","hasProp","prop","obj","hasMatch","chunkExists","chunk","clip","_ref3","curr","next","prev","clipBy","words","text","match","ellipsis","slice","__assign","Object","assign","hasLength","highlightWords","_ref4","query","safeQuery","key","searchRegexp","filter","map","toLowerCase","test","index","chunks"],"sources":["C:/xampp/htdocs/CourierHR/webapp/frontend/node_modules/highlight-words/dist/highlight-words.mjs"],"sourcesContent":["let IDX = 36;\nlet HEX = \"\";\nwhile (IDX--) {\n  HEX += IDX.toString(36);\n}\nfunction uid(len = 11) {\n  let str = \"\";\n  let num = len;\n  while (num--) {\n    str += HEX[Math.random() * 36 | 0];\n  }\n  return str;\n}\n\nconst escapeRegexp = (term) => term.replace(/[|\\\\{}()[\\]^$+*?.-]/g, (char) => `\\\\${char}`);\nconst termsToRegExpString = (terms) => {\n  return terms.replace(/\\s{2,}/g, \" \").split(\" \").join(\"|\");\n};\nconst regexpQuery = ({\n  terms,\n  matchExactly = false\n}) => {\n  if (typeof terms !== \"string\") {\n    throw new TypeError(\"Expected a string\");\n  }\n  const escapedTerms = escapeRegexp(terms.trim());\n  return `(${matchExactly ? escapedTerms : termsToRegExpString(escapedTerms)})`;\n};\nconst buildRegexp = ({\n  terms,\n  matchExactly = false\n}) => {\n  try {\n    const fromString = /^([/~@;%#'])(.*?)\\1([gimsuy]*)$/.exec(terms);\n    if (fromString) {\n      return new RegExp(fromString[2], fromString[3]);\n    }\n    return new RegExp(regexpQuery({terms, matchExactly}), \"ig\");\n  } catch (e) {\n    throw new TypeError(\"Expected terms to be either a string or a RegExp!\");\n  }\n};\n\nconst hasProp = (prop) => (obj) => obj !== null && typeof obj !== \"undefined\" && prop in obj;\nconst hasMatch = hasProp(\"match\");\nconst chunkExists = (chunk) => typeof chunk !== \"undefined\";\nfunction clip({\n  curr,\n  next,\n  prev,\n  clipBy = 3\n}) {\n  const words = curr.text.split(\" \");\n  const len = words.length;\n  if (curr.match || clipBy >= len) {\n    return curr.text;\n  }\n  const ellipsis = \"...\";\n  if (chunkExists(next) && chunkExists(prev) && hasMatch(prev) && hasMatch(next)) {\n    if (len > clipBy * 2) {\n      return [\n        ...words.slice(0, clipBy),\n        ellipsis,\n        ...words.slice(-clipBy)\n      ].join(\" \");\n    }\n    return curr.text;\n  }\n  if (chunkExists(next) && hasMatch(next)) {\n    return [ellipsis, ...words.slice(-clipBy)].join(\" \");\n  }\n  if (chunkExists(prev) && hasMatch(prev)) {\n    return [...words.slice(0, clipBy), ellipsis].join(\" \");\n  }\n  return curr.text;\n}\n\nvar __assign = Object.assign;\nconst hasLength = (str) => str.length > 0;\nconst highlightWords = ({\n  text,\n  query,\n  clipBy,\n  matchExactly = false\n}) => {\n  const safeQuery = typeof query === \"string\" ? query.trim() : query;\n  if (safeQuery === \"\") {\n    return [\n      {\n        key: uid(),\n        text,\n        match: false\n      }\n    ];\n  }\n  const searchRegexp = buildRegexp({terms: query, matchExactly});\n  return text.split(searchRegexp).filter(hasLength).map((str) => ({\n    key: uid(),\n    text: str,\n    match: matchExactly ? str.toLowerCase() === safeQuery.toLowerCase() : searchRegexp.test(str)\n  })).map((chunk, index, chunks) => __assign(__assign({}, chunk), typeof clipBy === \"number\" && {\n    text: clip(__assign(__assign(__assign({\n      curr: chunk\n    }, index < chunks.length - 1 && {next: chunks[index + 1]}), index > 0 && {prev: chunks[index - 1]}), {\n      clipBy\n    }))\n  }));\n};\n\nexport default highlightWords;\n"],"mappings":"AAAA,IAAIA,GAAG,GAAG,EAAE;AACZ,IAAIC,GAAG,GAAG,EAAE;AACZ,OAAOD,GAAG,EAAE,EAAE;EACZC,GAAG,IAAID,GAAG,CAACE,QAAQ,CAAC,EAAE,CAAC;AACzB;AACA,SAASC,GAAGA,CAAA,EAAW;EAAA,IAAVC,GAAG,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,EAAE;EACnB,IAAIG,GAAG,GAAG,EAAE;EACZ,IAAIC,GAAG,GAAGL,GAAG;EACb,OAAOK,GAAG,EAAE,EAAE;IACZD,GAAG,IAAIP,GAAG,CAACS,IAAI,CAACC,MAAM,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;EACpC;EACA,OAAOH,GAAG;AACZ;AAEA,MAAMI,YAAY,GAAIC,IAAI,IAAKA,IAAI,CAACC,OAAO,CAAC,sBAAsB,EAAGC,IAAI,IAAM,KAAIA,IAAK,EAAC,CAAC;AAC1F,MAAMC,mBAAmB,GAAIC,KAAK,IAAK;EACrC,OAAOA,KAAK,CAACH,OAAO,CAAC,SAAS,EAAE,GAAG,CAAC,CAACI,KAAK,CAAC,GAAG,CAAC,CAACC,IAAI,CAAC,GAAG,CAAC;AAC3D,CAAC;AACD,MAAMC,WAAW,GAAGC,IAAA,IAGd;EAAA,IAHe;IACnBJ,KAAK;IACLK,YAAY,GAAG;EACjB,CAAC,GAAAD,IAAA;EACC,IAAI,OAAOJ,KAAK,KAAK,QAAQ,EAAE;IAC7B,MAAM,IAAIM,SAAS,CAAC,mBAAmB,CAAC;EAC1C;EACA,MAAMC,YAAY,GAAGZ,YAAY,CAACK,KAAK,CAACQ,IAAI,EAAE,CAAC;EAC/C,OAAQ,IAAGH,YAAY,GAAGE,YAAY,GAAGR,mBAAmB,CAACQ,YAAY,CAAE,GAAE;AAC/E,CAAC;AACD,MAAME,WAAW,GAAGC,KAAA,IAGd;EAAA,IAHe;IACnBV,KAAK;IACLK,YAAY,GAAG;EACjB,CAAC,GAAAK,KAAA;EACC,IAAI;IACF,MAAMC,UAAU,GAAG,iCAAiC,CAACC,IAAI,CAACZ,KAAK,CAAC;IAChE,IAAIW,UAAU,EAAE;MACd,OAAO,IAAIE,MAAM,CAACF,UAAU,CAAC,CAAC,CAAC,EAAEA,UAAU,CAAC,CAAC,CAAC,CAAC;IACjD;IACA,OAAO,IAAIE,MAAM,CAACV,WAAW,CAAC;MAACH,KAAK;MAAEK;IAAY,CAAC,CAAC,EAAE,IAAI,CAAC;EAC7D,CAAC,CAAC,OAAOS,CAAC,EAAE;IACV,MAAM,IAAIR,SAAS,CAAC,mDAAmD,CAAC;EAC1E;AACF,CAAC;AAED,MAAMS,OAAO,GAAIC,IAAI,IAAMC,GAAG,IAAKA,GAAG,KAAK,IAAI,IAAI,OAAOA,GAAG,KAAK,WAAW,IAAID,IAAI,IAAIC,GAAG;AAC5F,MAAMC,QAAQ,GAAGH,OAAO,CAAC,OAAO,CAAC;AACjC,MAAMI,WAAW,GAAIC,KAAK,IAAK,OAAOA,KAAK,KAAK,WAAW;AAC3D,SAASC,IAAIA,CAAAC,KAAA,EAKV;EAAA,IALW;IACZC,IAAI;IACJC,IAAI;IACJC,IAAI;IACJC,MAAM,GAAG;EACX,CAAC,GAAAJ,KAAA;EACC,MAAMK,KAAK,GAAGJ,IAAI,CAACK,IAAI,CAAC3B,KAAK,CAAC,GAAG,CAAC;EAClC,MAAMd,GAAG,GAAGwC,KAAK,CAACtC,MAAM;EACxB,IAAIkC,IAAI,CAACM,KAAK,IAAIH,MAAM,IAAIvC,GAAG,EAAE;IAC/B,OAAOoC,IAAI,CAACK,IAAI;EAClB;EACA,MAAME,QAAQ,GAAG,KAAK;EACtB,IAAIX,WAAW,CAACK,IAAI,CAAC,IAAIL,WAAW,CAACM,IAAI,CAAC,IAAIP,QAAQ,CAACO,IAAI,CAAC,IAAIP,QAAQ,CAACM,IAAI,CAAC,EAAE;IAC9E,IAAIrC,GAAG,GAAGuC,MAAM,GAAG,CAAC,EAAE;MACpB,OAAO,CACL,GAAGC,KAAK,CAACI,KAAK,CAAC,CAAC,EAAEL,MAAM,CAAC,EACzBI,QAAQ,EACR,GAAGH,KAAK,CAACI,KAAK,CAAC,CAACL,MAAM,CAAC,CACxB,CAACxB,IAAI,CAAC,GAAG,CAAC;IACb;IACA,OAAOqB,IAAI,CAACK,IAAI;EAClB;EACA,IAAIT,WAAW,CAACK,IAAI,CAAC,IAAIN,QAAQ,CAACM,IAAI,CAAC,EAAE;IACvC,OAAO,CAACM,QAAQ,EAAE,GAAGH,KAAK,CAACI,KAAK,CAAC,CAACL,MAAM,CAAC,CAAC,CAACxB,IAAI,CAAC,GAAG,CAAC;EACtD;EACA,IAAIiB,WAAW,CAACM,IAAI,CAAC,IAAIP,QAAQ,CAACO,IAAI,CAAC,EAAE;IACvC,OAAO,CAAC,GAAGE,KAAK,CAACI,KAAK,CAAC,CAAC,EAAEL,MAAM,CAAC,EAAEI,QAAQ,CAAC,CAAC5B,IAAI,CAAC,GAAG,CAAC;EACxD;EACA,OAAOqB,IAAI,CAACK,IAAI;AAClB;AAEA,IAAII,QAAQ,GAAGC,MAAM,CAACC,MAAM;AAC5B,MAAMC,SAAS,GAAI5C,GAAG,IAAKA,GAAG,CAACF,MAAM,GAAG,CAAC;AACzC,MAAM+C,cAAc,GAAGC,KAAA,IAKjB;EAAA,IALkB;IACtBT,IAAI;IACJU,KAAK;IACLZ,MAAM;IACNrB,YAAY,GAAG;EACjB,CAAC,GAAAgC,KAAA;EACC,MAAME,SAAS,GAAG,OAAOD,KAAK,KAAK,QAAQ,GAAGA,KAAK,CAAC9B,IAAI,EAAE,GAAG8B,KAAK;EAClE,IAAIC,SAAS,KAAK,EAAE,EAAE;IACpB,OAAO,CACL;MACEC,GAAG,EAAEtD,GAAG,EAAE;MACV0C,IAAI;MACJC,KAAK,EAAE;IACT,CAAC,CACF;EACH;EACA,MAAMY,YAAY,GAAGhC,WAAW,CAAC;IAACT,KAAK,EAAEsC,KAAK;IAAEjC;EAAY,CAAC,CAAC;EAC9D,OAAOuB,IAAI,CAAC3B,KAAK,CAACwC,YAAY,CAAC,CAACC,MAAM,CAACP,SAAS,CAAC,CAACQ,GAAG,CAAEpD,GAAG,KAAM;IAC9DiD,GAAG,EAAEtD,GAAG,EAAE;IACV0C,IAAI,EAAErC,GAAG;IACTsC,KAAK,EAAExB,YAAY,GAAGd,GAAG,CAACqD,WAAW,EAAE,KAAKL,SAAS,CAACK,WAAW,EAAE,GAAGH,YAAY,CAACI,IAAI,CAACtD,GAAG;EAC7F,CAAC,CAAC,CAAC,CAACoD,GAAG,CAAC,CAACvB,KAAK,EAAE0B,KAAK,EAAEC,MAAM,KAAKf,QAAQ,CAACA,QAAQ,CAAC,CAAC,CAAC,EAAEZ,KAAK,CAAC,EAAE,OAAOM,MAAM,KAAK,QAAQ,IAAI;IAC5FE,IAAI,EAAEP,IAAI,CAACW,QAAQ,CAACA,QAAQ,CAACA,QAAQ,CAAC;MACpCT,IAAI,EAAEH;IACR,CAAC,EAAE0B,KAAK,GAAGC,MAAM,CAAC1D,MAAM,GAAG,CAAC,IAAI;MAACmC,IAAI,EAAEuB,MAAM,CAACD,KAAK,GAAG,CAAC;IAAC,CAAC,CAAC,EAAEA,KAAK,GAAG,CAAC,IAAI;MAACrB,IAAI,EAAEsB,MAAM,CAACD,KAAK,GAAG,CAAC;IAAC,CAAC,CAAC,EAAE;MACnGpB;IACF,CAAC,CAAC;EACJ,CAAC,CAAC,CAAC;AACL,CAAC;AAED,eAAeU,cAAc"},"metadata":{},"sourceType":"module","externalDependencies":[]}